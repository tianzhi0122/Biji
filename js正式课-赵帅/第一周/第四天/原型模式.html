<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>201803JS</title>
    <meta name="description" content=""/>
    <meta name="Keywords" content=""/>
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <link rel="icon" href="">
    <link rel="stylesheet" href="">
</head>
<body>

</body>
</html>
<script>
    /*原型模式
    * 1.每一个函数都有一个天生自带的属性，叫prototype（原型），它是一个对象数据类型，它是当前类的实例的公有方法
    * 2.prototype有一个天生自带的属性constructor，它指向当前函数类本身
    * 3.每一个对象都自带一个属性__proto__，它指向的是当前所属类的原型
    * object的prototype属性上的__proto__指向的还是自己，所以浏览器将其去掉这个属性
    * */
    function Fn (name,age){
        var age =1 ;
        this.name = name
        this.age = function (){
            console.log(age)
        }
        this.sit = function(){
            console.log(name + 'this.age');
        }
        this.speak = function (){
            return this.age
        }
    }
    Fn.prototype.speak = function (){
        console.log(age)
        return this.age
    }
    Fn.prototype.sit = function (){
        console.log(name)
    }
    var f1 = new Fn('zhufeng',8)
    var f2 = new Fn('zhufengpeixun',9)
    f1.__proto__.name == f2.name  //false
    f1.__proto__.speak == f2.speak  //false
    f1.__proto__ == Fn.prototype;//true
    Fn.prototype.constructor == f1//false
    typeof  (Fn.prototype)//"object"
    typeof  (f1.__proto__)//"object"
    f1.speak() == f2.speak()//false
</script>